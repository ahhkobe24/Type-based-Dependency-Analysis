<html>
<head>
<style>
body{
margin: 20px;
color: black;
background - color: #eee;
font - family: Consolas;
font - weight: 600;
font - size: 110 % ;}
.indent{ margin - left: 20px; margin - right: 20px;}
h4{margin - bottom: 3px;margin - top: 3px;}
</style>
</head>
<body>
<h3>CppProperties.h</h3>
<hr/>
<pre>
<script>function ShowIt(id) {
if (id.style.display == "block")
id.style.display = "none";
else
id.style.display = "block";
};
</script>
<style>div{ display:inline }</style>#pragma once
#pragma once
/////////////////////////////////////////////////////////////////////
// CppProperties.h - Defines read/write and read only properties   //
// ver 1.1                                                         //
// Source: Michael Litvin (see link below)                         //
// Jim Fawcett, CSE687 - Object Oriented Design, Spring 2017       //
/////////////////////////////////////////////////////////////////////
//
// Got the idea from discussion here (scroll down about halfway):
// http://stackoverflow.com/questions/8368512/does-c11-have-c-style-properties
// This implementation is quite different however.
/*
* Package Operations:
* -------------------
* This package provides two classes, Property&lt;T&gt;, and Property&lt;const T&gt;,
* a template specialization of Property&lt;T&gt;.
*
* Both classes wrap an instance of the template type and provide methods:
* - Property&lt;T&gt;& operator=(const T& t) - sets internal value by assignment
* - operator const T() - gets copy of wrapped type
*   (properties only changed by assignment)
* - T& getValue() - returns a reference to wrapped instance so you can change
*   in a non-property way.
*   Without getValue() you need to get the copy with the cast operation, change it
*   then assign the copy back to the property.
*
* Note:
* -----
*   These properties provide virtual methods to support changing the
*   operation of getter and setter.  But, you don't usually want to
*   override because that changes the name of the property.  For example
*   see the Y class defined in CppProperties.cpp.
*
*   Instead, you should prefer to use the methods to provide new getter
*   and setter functions to change the property behaviors, as that
*   does not change the user's interface. That's illustrated in the test stub.
*
* Maintenance History:
* --------------------
* ver 1.1 : Jan 28 2017
* - fixed bug in Property class by removing bound data from all lambdas.
* ver 1.0 : Jan 08 2017
* - first release
*
*/
#include &lt;iostream&gt;
#include &lt;functional&gt;

/////////////////////////////////////////////////////////////////////
// Property&lt;T&gt; class provides encapsulated properties for C++
// - getter and setter functions can be customized without changing
//   the client interface for any class that uses Property&lt;T&gt;
//
template&lt;typename T&gt;
class Property
<div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(a)">+</span></div><section id = "a">{
public:
	using SetterType = std::function&lt;T(const T& t)&gt;;
	using GetterType = std::function&lt;T(const T& t)&gt;;

	// initialize the property field

	Property() : value(T()) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aa)">+</span></div><section id = "aa">{}</section>
	Property(const T& t) : value(t) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaa)">+</span></div><section id = "aaa">{}</section>
	virtual ~Property() <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaa)">+</span></div><section id = "aaaa">{}</section>

	// set the property field with assignment operator

	virtual Property&lt;T&gt;& operator=(const T &t)
	{
		value = setter_(t);
		return *this;
	}
	// get the property field with cast operator --- returns copy !

	virtual operator const T() const <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaa)">+</span></div><section id = "aaaaa">{ return getter_(value); }</section>

	// define methods to customize getter and setter behaviors

	void newSetter(SetterType sttr) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaa)">+</span></div><section id = "aaaaaa">{ setter_ = sttr; }</section>
	void newGetter(GetterType gttr) { getter_ = gttr; }

	T& getValue() { return value; }  // You can get reference to value using getValue()

protected:
	T value;  // property field

			  // define default getter and setter behavior using lambdas

	SetterType setter_ = [](const T& t) { return t; };   // default setter
	GetterType getter_ = [](const T& v) { return v; };   // default getter
}</section>;

/*----&lt; overload insertion operator for std::string properties &gt;---*/

inline std::ostream& operator&lt;&lt;(std::ostream& out, Property&lt;std::string&gt;& p)
<div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaa)">+</span></div><section id = "aaaaaaa">{
	std::string temp = p;
	try {
		out &lt;&lt; (temp).c_str();
	}
	catch (std::exception& ex)
	{
		std::cout &lt;&lt; "\n  exception:\n  " &lt;&lt; ex.what() &lt;&lt; "\n";
	}
	return out;
}</section>

/////////////////////////////////////////////////////////////////////
// Property&lt;const T&gt; class provides encapsulated properties for C++
// - getter function can be customized without changing
//   the client interface for any class that uses Property&lt;T&gt;
// - no setter is provided since the class is used for const properties
// - comments for this class would be same as above, and so are omitted
//
template&lt;typename T&gt;
class Property&lt;const T&gt;
<div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaa)">+</span></div><section id = "aaaaaaaa">{
public:
	using SetterType = std::function&lt;T(const T&t)&gt;;
	using GetterType = std::function&lt;T(const T&t)&gt;;

	Property() : value(T()) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaa)">+</span></div><section id = "aaaaaaaaa">{}</section>
	Property(const T& t) : value(t) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaaa)">+</span></div><section id = "aaaaaaaaaa">{}</section>
	virtual ~Property() <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaaaa)">+</span></div><section id = "aaaaaaaaaaa">{}</section>
	void newGetter(GetterType gttr) <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaaaaa)">+</span></div><section id = "aaaaaaaaaaaa">{ getter_ = gttr; }</section>
	virtual operator const T() const { return getter_(value); }
	T getValue() <div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaaaaaa)">+</span></div><section id = "aaaaaaaaaaaaa">{ return value; }</section>                      // used by custom getters
protected:
	T value;
	GetterType getter_ = [](const T& v) { return v; };  // default getter
}</section>;

/*----&lt; overload insertion operator for std::string properties &gt;---*/

inline std::ostream& operator&lt;&lt;(std::ostream& out, Property&lt;const std::string&gt;& p)
<div class = "wrapper"><span  style="width:30px; height:20px; color:red;"  onclick="ShowIt(aaaaaaaaaaaaaa)">+</span></div><section id = "aaaaaaaaaaaaaa">{
	std::string temp = p;
	try {
		out &lt;&lt; (temp).c_str();
	}
	catch (std::exception& ex)
	{
		std::cout &lt;&lt; "\n  exception:\n  " &lt;&lt; ex.what() &lt;&lt; "\n";
	}
	return out;
}</section>


</pre>
</body>
</html>
